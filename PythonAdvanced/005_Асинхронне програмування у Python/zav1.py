# Створіть співпрограму, яка отримує контент із зазначених посилань і логує хід
# виконання в database, використовуючи стандартну бібліотеку requests, а потім проробіть
# те саме з бібліотекою aiohttp. Кроки, які мають бути залоговані: початок запиту до адреси X,
# відповідь для адреси X отримано зі статусом 200. Перевірте хід виконання програми
# на >3 ресурсах і перегляньте послідовність запису логів в обох варіантах і порівняйте
# результати. Для двох видів завдань використовуйте різні файли для логування, щоби порівняти
# отриманий результат.

import asyncio
import aiohttp
import logging
import time

async def fetch(session, url):
    start_time = time.time()
    async with session.get(url) as response:
        end_time = time.time()
        logging.info(f"Запит до адреси {url} почато")
        logging.info(f"Відповідь для адреси {url} отримано зі статусом {response.status}")
        logging.info(f"Час виконання запиту: {end_time - start_time} сек.")

async def main():
    logging.basicConfig(filename='async_log.txt', level=logging.INFO, format='%(asctime)s - %(message)s')

    urls = ['https://www.example.com', 'https://www.python.org', 'https://www.google.com']

    async with aiohttp.ClientSession() as session:
        tasks = []
        for url in urls:
            task = asyncio.create_task(fetch(session, url))
            tasks.append(task)
        await asyncio.gather(*tasks)

if __name__ == '__main__':
    asyncio.run(main())

# Порівняння результатів

# Порядок виконання:

# Синхронна: Запити виконуються послідовно, один за одним.
# Асинхронна: Запити виконуються паралельно, і порядок завершення може відрізнятися.
# Час виконання:
# Асинхронна: Зазвичай швидша, особливо для великої кількості запитів, оскільки вона не блокується під час
# очікування відповідей.
# Логи:

# Порівняйте файли sync_log.txt та async_log.txt. Зверніть увагу на час початку та завершення кожного запиту,
# а також на порядок записів.

# Висновок

# Асинхронне програмування з використанням aiohttp дозволяє значно підвищити ефективність при виконанні великої кількості мережевих запитів. requests краще підходить для простих сценаріїв, де не потрібна висока продуктивність.
#
# Важливі моменти:
#
# Асинхронність не завжди швидша: Для невеликої кількості запитів різниця у швидкодії може бути незначною або навіть відсутньою.
# Складність: Асинхронний код може бути складнішим для розуміння та відлагодження, ніж синхронний.
# Вибір бібліотеки: Вибір між requests та aiohttp залежить від конкретного завдання та вимог до продуктивності.
# Додаткові можливості:
#
# Використання async/await: Для більш зручного написання асинхронного коду.
# Обробка помилок: Додавання механізмів обробки помилок та повторних спроб.
# Лімітування одночасних запитів: Для запобігання перевантаження сервера.
# Використання інших асинхронних бібліотек: asyncio, uvloop.
# Завдання для самостійної роботи:
#
# Додайте обробку помилок в обидві програми.
# Реалізуйте лімітування одночасних запитів в асинхронній програмі.
# Порівняйте продуктивність для більшої кількості URL.
# Додайте можливість зберігання результатів в базу даних.